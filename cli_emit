#!/usr/bin/env bash
source $(cli loader)

export() {
    EMIT_TAB="    "

    emit::new_line() {
        echo
    }

    emit::comment() {
        echo "# $1"
    }

    emit::header() {
        if ! read -r; then
            return
        fi

        echo
        emit::comment "$1"
        echo "${REPLY}"

        while read -r; do echo "${REPLY}"; done
    }

    emit::comments() {
        sed 's/^/\# /'
    }

    emit::shebang() {
        echo \#!/usr/bin/env bash
    }

    emit::file() {
        # emit content to include last 'pseudo' line
        # (see https://stackoverflow.com/a/12919766/2303356)
        while read -r || [ -n "${REPLY}" ]; do 
            echo "${REPLY}"
        done
    }

    emit::indent() {
        local regex='<< ([A-Z]+)'
        local eof=

        while read -r; do

            # start heredoc
            if [[ "${REPLY}" =~ ${regex} ]]; then
                echo "${EMIT_TAB}${REPLY}"
                eof=${BASH_REMATCH[1]}

                # in heredoc
                while read -r; do
                    echo "${REPLY}"
                
                    # end heredoc
                    if [[ "${REPLY}" == "${eof}" ]]; then
                        break
                    fi
                done

                continue
            fi

            echo "${EMIT_TAB}${REPLY}"
        done
    }

    emit::function() {
        echo "$1() {"
        emit::indent
        echo "}"
    }

    emit::subproc() {
        echo "$1() ("
        emit::indent
        echo ")"
    }

    emit::noop() {
        echo ':'
    }

    emit::continuation() {
        if ! read -r; then 
            return
        fi

        echo -n "${REPLY}"

        while read -r; do
            echo ' \'
            echo -n "${REPLY}"
        done

        echo
    }

    emit::process_substitution() {
        echo "<($1)"
    }

    emit::shift() {
        echo "shift"
    }

    emit::declare() {
        echo -n "declare $1 $2"
        if (( $# == 3 )); then echo -n "=\"$3\""; fi
        echo
    }

    emit::declare_global() {
        emit::declare -g $1 "${2-}"
    }

    emit::declare_global_array() {
        echo "declare -ga $1=()"
    }

    emit::declare_global_map() {
        echo "declare -gA $1=()"
    }

    emit::map_set() {
        echo "$1[$2]=\"$3\""
    }

    emit::variable_required() {
        echo ": \${$1?$2}"
    }

    emit::while() {
        echo "while $1; do"
        emit::indent
        echo "done"
    }

    emit::break() {
        echo 'break'
    }

    emit::continue() {
        echo 'continue'
    }
        
    emit::function_contains() {
        while read -r; do 
            echo 'true' \
                | emit::case_inline "${REPLY}"
        done \
        | cat - <(emit::case_default_inline false) \
        | emit::case_statement '$1' \
        | emit::function $1
    }

    emit::case_statement() {
        echo "case \"$1\" in"
        emit::indent
        echo "esac"
    }

    emit::case_raw() {
        echo "$1)"
        emit::indent
        echo ";;" 
    }

    emit::case() {
        emit::case_raw "'$1'"
    }

    emit::case_default() {
        emit::case_raw '*'
    }

    emit::case_inline() {
        read -r
        echo "'$1') $REPLY ;;"
    }

    emit::case_default_inline() {
        echo "*) $1 ;;"
    }
    
    emit::case_noop() {
        echo "'$1') ;;"
    }

    emit::assign() {
        echo "$1=$2"
    }

    emit::assign_string() {
        emit::assign "$1" "\"$2\""
    }

    emit::error() {
        echo echo \""$1"\" '>&2'
        echo "exit 1"
    }

    emit::inline() {
        local delimiter=
        while read -r; do
            echo -n "${delimiter}${REPLY}"
            delimiter='; '
        done
        echo
    }

    emit::call() {
        echo -n "$1"
        for i in "${@:2}"; do
            echo -n " "
            echo -n "\"$i\""
        done
        echo
    }

    emit::if() {
        echo "if $1; then"
        emit::indent
        echo "fi"
    }

    emit::if_empty() {
        emit::if "[[ -z \"\${$1}\" ]]"
    }

    self_test() {
        echo foo | emit::case 'a' | emit::case_statement 'x'
    }

    cli::export emit
}

cli::load "$@"